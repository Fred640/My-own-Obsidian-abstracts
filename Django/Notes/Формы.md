```
<form action="" method="POST">   w         #action - какая функция представления будет обробатывать запрос ("" - текущая функция) mehod - какой запрос будет отправляться на сервер
{% csrf_token %}                          #CSRF - защита сайта от меж сайтовых атак, Django требует его при каждом post запросе
<label for="login-input">Логин</label>
	<input type="text" id='login-input' name="login">         #name - имя поля в get запросе
	<label for="password-input">Пароль</label>
	<input type="text" id='password-input' name="password">
	<button type="submit">Войти</button>                      #type="submit" - кнопка для отправки get запроса
</form>
```
При нажатии кнопки с type="submit" происходит отправка данных на сервер. Осуществляется следующий get запрос `..../?<input_name1>=<input_data>&input_name2>=<input_data>`
``..../?login=fred&password=123`

post - отправка данных на сервер
get - прием данных с севера
CSRF - защита сайта от меж сайтовых атак, Django требует его при каждом post запросе

Создание форм можно осуществить через классы
```
#<AppName>/forms.py
from django import forms
from .models import People, Categories


class AddPostForm(forms.Form):
#поля формы следует называть также как и поля модели
	name = forms.CharField(max_length=100)
	slug = forms.SlugField(max_length=255)
	content = forms.CharField(widget=forms.Textarea())
	isPublished = forms.BooleanField()
	category = forms.ModelChoiceField(queryset=Categories.objects.all())
```
# Встроенные Field классы:

###### CharField - текст
label="" - заголовок
###### BooleanField - True/False
default_widget - CheckBoxInput
initial = True/False - значение по умолчанию


###### ChoiceField - поле выбора
default_widget - select
empty_label - надпись при пустом селекте
initial - вариант по умолчанию 
###### ModelChoiceField - поле выбора со значениями связанными с полями модели
empty_label - надпись при пустом селекте
initial - вариант по умолчанию 
queryset - модель для создания выборки 

###### MultipleChoiceField - поле выбора нескольких значений
default_widget - selectMultiple
###### DateField - дата
default_widget - DateTimeInput

###### DecimalField - float()
default_widget - NumberInput
max_value
min_value
max_digits
decimal_places

###### DurationField - промежуток времени
default_widget - TextInput
###### EmailField - почта
default_widget - EmailInput

###### FileField - файл
default_widget - ClearableFileInput

###### FilePathField - путь к файлу
default_widget - select
path - путь к директории из которой будет выбираться файл
recursive - будут ли в выборке подкаталоги и их содержимое

###### IntegerField - цифра

###### JSONField - текст в формате json
###### SlugField


# Добавление формы в функцию представления
```
#<AppName>/views.py
def add(request):
	if request.method == 'POST':
		form = AddPostForm(request.POST)
		if form.is_valid():
			People.objects.create(**form.cleaned_data)
			return redirect("home")
	else:
		form = AddPostForm()
	data = {"form":form}
	return render(request, "people/addPage.html", data)
```


```
<AppName>/template.html
{% extends "base.html" %}
{% block content %}
<div>
	<form method="post">
		{% csrf_token %}
		{{form.as_p}}                              #подключение формы
		<button type="submit">Создать</button>
	</form>
</div>
{% endblock content %}
```

При заполнении и отправке формы получаем следующие запросы
```
[25/Nov/2025 17:13:23] "GET /add-page/ HTTP/1.1" 200 18208
[25/Nov/2025 17:13:32] "POST /add-page/ HTTP/1.1" 302 0
[25/Nov/2025 17:13:32] "GET / HTTP/1.1" 200 17060
```

Создание формы связанной с моделью
```
class AddPostForm(forms.ModelForm):
	class Meta:
		model = People #Связь с моделью
		fields = "__all__" #Каки поля из бд будут в форме __all__ если нужны все поля кроме тех которые заполняются автоматически
		widgets = {
			"name": forms.TextInput(),
			"content": forms.Textarea()
		} 
	def clean_name(self):
		name = self.cleaned_data["name"]
		if len(name) > 100:
			raise ValidationError("to long title")
		return name
```

