при таком виде оробатывания события нельзя повесить на одно событие два обработчика
```
const buttonElement = document.querySelector('button')
let count = 1
buttonElement.onclick = () => {
    console.log(count)
    count++
}
```
или
buttonElement.onclick = logMessage
 
 
 
buttonElement.addEventListener("click", logMessage)
buttonElement.removeEventListener("click", logMessage)
 
в рамках функции обработчика события через первый параметр функции у нас есть доступ к обьекту который имеет полную информацию о случившимся событии (event)
 
bubling - всплытие событий по DOM дереву от элемента на котором произошло событие до корня DOM
 
самый глубокий эдемент с которого событие начинает всплывать называеться целевым элементом
доступ к нему можно полуить с помощью event.target
 
есть еще event.currentTarget это элемент который обработал событие в данный момент (к нему также можно полуить доступ с помощью ключевого слова this в рамках тела функции. Для каждой функции обработчика событий this ссылаеться на соответствующий обработчику элемент)
 
event.stopPropogation в функции обработчика чтобы отменить всплытие события дальше this
event.stopimmediatePropogation в функции обработчика чтобы отменить действия других функций обработчиков у данного элемента по этому же событию
 
при добавлении функции обработчика события через метод addEventListener можно добавить третий аргумент true или false (по умолчанию false) чтобы включить/выключить обработку погружения события
 
Создание собственного события
const myEvent = new Event("eventName" , {})      
Element.dispatchEvent(myEvent)                 - вызов события у элемента
 
создание события с возможностью добовлять свойства
const myEvent = new CustomEvent("eventName", {bubbles: true,
    detail: {
       
    }
})
 
 
удаление действий браузера по умолчанию
Element.addEventListener("click", (event) => {
    event.preventDefault()
})